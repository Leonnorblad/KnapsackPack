ret_value
elements
W<-15000
ret_value<-0
elements<-c()
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[y]
}
return(list(value=ret_value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
rm(value)
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[y]
}
return(list(value=ret_value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){
value<-0
}
# if(weight<=W & value>ret_value){
#   ret_value <- value
#   elements <- (1:n)[y]
#
# }
return(list(value=max(value), elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){
value<-0
} else {
return(value)
}
# if(weight<=W & value>ret_value){
#   ret_value <- value
#   elements <- (1:n)[y]
#
# }
#return(list(value=max(value), elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){
value<-0
} else {
return(max(value))
}
# if(weight<=W & value>ret_value){
#   ret_value <- value
#   elements <- (1:n)[y]
#
# }
#return(list(value=max(value), elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
apply(ret_list, 1, max)
apply(ret_list, 2, max)
ret_list
lapply(ret_list, max)
unlist(ret_list)
unlist(ret_list)$value
lapply(ret_list, FUN=max)
which.max()[ret_list]
which.max([ret_list])
which.max(ret_list)
which.max(ret_list)
ret_list
lapply(ret_list,FUN=max)
m1 <- cbind(c(1,2,3),c(7,2,4))
m2 <- cbind(c(-1,19,13),c(21,3,5),c(3,3,0),c(4,5,6))
m3 <- cbind(c(1,2,3,4,5),c(8,18,4,6,7))
mylist <- list(M1=m1,M2=m2,M3=m3)
lapply(mylist,FUN=max)
mylist
ret_list
lapply(mylist,FUN=max)
mylist
ret_list
which.max(ret_list)
ret_list[[2]]
which.max(ret_list[[2]])
unlist(ret_list)
unlist(ret_list)[unlist(ret_list)=="value"]
names(unlist(ret_list))=="value"
unlist(ret_list)[names(unlist(ret_list))=="value"]
which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])
which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])[]
which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])[[]]
which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])[[]]
ret_list
ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]]
brute_force_knapsack <- function(x,W, parallel=FALSE){
# Check input
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
# Inital values
ret_value <- 0
elements <- NA
value <- NA
# n=number of elements in data
n <- nrow(x)
# All combinations
all_test <- expand.grid(rep(list(0:1), n))==1
if(parallel==TRUE){
w = x$w
v = x$v
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
return(ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]])
} else {
# Iterating over all combinations
for (i in 1:nrow(all_test)) {
# Current test
current_test <- all_test[i,]
# Value of current test
value <- sum(x$v[current_test])
# Weight of current test
weight <- sum(x$w[current_test])
# If weight is less than knapsack size (W) and value is less than previous least value
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[current_test]
}
}
# Return the most optimum of values and elements
return(list(value=ret_value, elements=elements))
}
}
brute_force_knapsack <- function(x,W, parallel=FALSE){
# Check input
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
# Inital values
ret_value <- 0
elements <- NA
value <- NA
# n=number of elements in data
n <- nrow(x)
# All combinations
all_test <- expand.grid(rep(list(0:1), n))==1
if(parallel==TRUE){
w = x$w
v = x$v
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
return(ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]])
} else {
# Iterating over all combinations
for (i in 1:nrow(all_test)) {
# Current test
current_test <- all_test[i,]
# Value of current test
value <- sum(x$v[current_test])
# Weight of current test
weight <- sum(x$w[current_test])
# If weight is less than knapsack size (W) and value is less than previous least value
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[current_test]
}
}
# Return the most optimum of values and elements
return(list(value=ret_value, elements=elements))
}
}
suppressWarnings(RNGversion(min(as.character(getRversion()),"3.5.3")))
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
x <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000))
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500)
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = TRUE)
brute_force_knapsack <- function(x,W, parallel=FALSE){
# Check input
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
# Inital values
ret_value <- 0
elements <- NA
value <- NA
# n=number of elements in data
n <- nrow(x)
# All combinations
all_test <- expand.grid(rep(list(0:1), n))==1
if(parallel==TRUE){
w = x$w
v = x$v
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
return(ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]])
} else {
# Iterating over all combinations
for (i in 1:nrow(all_test)) {
# Current test
current_test <- all_test[i,]
# Value of current test
value <- sum(x$v[current_test])
# Weight of current test
weight <- sum(x$w[current_test])
# If weight is less than knapsack size (W) and value is less than previous least value
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[current_test]
}
}
# Return the most optimum of values and elements
return(list(value=ret_value, elements=elements))
}
}
suppressWarnings(RNGversion(min(as.character(getRversion()),"3.5.3")))
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
x <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000))
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = TRUE)
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = FALSE)
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = TRUE)
x[1:8,]
x=x[1:8,]
W=3500
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0
# Inital values
ret_value <- 0
elements <- NA
value <- NA
n <- nrow(x)
all_test <- expand.grid(rep(list(0:1), n))==1
w = x$w
v = x$v
ff <-function(y){
value <- sum(w[y])
weight <- sum(v[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
ret_list
suppressWarnings(RNGversion(min(as.character(getRversion()),"3.5.3")))
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
x <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000))
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = TRUE)
brute_force_knapsack <- function(x,W, parallel=FALSE){
# Check input
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
# Inital values
ret_value <- 0
elements <- NA
value <- NA
# n=number of elements in data
n <- nrow(x)
# All combinations
all_test <- expand.grid(rep(list(0:1), n))==1
if(parallel==TRUE){
w = x$w
v = x$v
ff <-function(y){
value <- sum(v[y])
weight <- sum(w[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- apply(all_test, 1, ff)
return(ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]])
} else {
# Iterating over all combinations
for (i in 1:nrow(all_test)) {
# Current test
current_test <- all_test[i,]
# Value of current test
value <- sum(x$v[current_test])
# Weight of current test
weight <- sum(x$w[current_test])
# If weight is less than knapsack size (W) and value is less than previous least value
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[current_test]
}
}
# Return the most optimum of values and elements
return(list(value=ret_value, elements=elements))
}
}
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = TRUE)
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = FALSE)
library(parallel)
library(MASS)
numCores <- detectCores()
numCores
numCores <- detectCores()
numCores
cl <- makeCluster(cores, type = "PSOCK")
cl <- makeCluster(numCores, type = "PSOCK")
cl
parLapply(cl, all_test, 1, ff)
parLapply(cl, all_test, 1, ff)
?parLapply
parLapply(cl, all_test, 1, FUN=ff)
parApply(cl, all_test, 1, ff)
brute_force_knapsack <- function(x,W, parallel=FALSE){
# Check input
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
# Inital values
ret_value <- 0
elements <- NA
value <- NA
# n=number of elements in data
n <- nrow(x)
# All combinations
all_test <- expand.grid(rep(list(0:1), n))==1
if(parallel==TRUE){
numCores <- detectCores()
cl <- makeCluster(numCores, type = "PSOCK")
w = x$w
v = x$v
ff <-function(y){
value <- sum(v[y])
weight <- sum(w[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- parApply(cl, all_test, 1, ff)
stopCluster(cl)
return(ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]])
} else {
# Iterating over all combinations
for (i in 1:nrow(all_test)) {
# Current test
current_test <- all_test[i,]
# Value of current test
value <- sum(x$v[current_test])
# Weight of current test
weight <- sum(x$w[current_test])
# If weight is less than knapsack size (W) and value is less than previous least value
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[current_test]
}
}
# Return the most optimum of values and elements
return(list(value=ret_value, elements=elements))
}
}
suppressWarnings(RNGversion(min(as.character(getRversion()),"3.5.3")))
set.seed(42, kind = "Mersenne-Twister", normal.kind = "Inversion")
n <- 2000
x <- data.frame(
w = sample(1:4000, size = n, replace = TRUE),
v = runif(n = n, 0, 10000))
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = FALSE)
# Run the algorithm for the first eight values from the example data
brute_force_knapsack(x=x[1:8,], W=3500, parallel = TRUE)
brute_force_knapsack <- function(x,W, parallel=FALSE){
# Check input
if(!is.data.frame(x)|
any(!(names(x) %in% c("w", "v")))|
!any(is.numeric(x$w))|
!any(is.numeric(x$v))|
any(x<0)|
W<0) { stop("False input")}
# Inital values
ret_value <- 0
elements <- NA
value <- NA
# n=number of elements in data
n <- nrow(x)
# All combinations
all_test <- expand.grid(rep(list(0:1), n))==1
if(parallel==TRUE){
numCores <- detectCores()
cl <- makeCluster(numCores, type = "PSOCK")
w = x$w
v = x$v
ff <-function(y){
value <- sum(v[y])
weight <- sum(w[y])
elements <- (1:n)[y]
if(weight>W){value<-0}
return(list(value=value, elements=elements))
}
ret_list <- parApply(cl, all_test, 1, ff)
stopCluster(cl)
return(ret_list[[which.max(unlist(ret_list)[names(unlist(ret_list))=="value"])]])
} else {
# Iterating over all combinations
for (i in 1:nrow(all_test)) {
# Current test
current_test <- all_test[i,]
# Value of current test
value <- sum(x$v[current_test])
# Weight of current test
weight <- sum(x$w[current_test])
# If weight is less than knapsack size (W) and value is less than previous least value
if(weight<=W & value>ret_value){
ret_value <- value
elements <- (1:n)[current_test]
}
}
# Return the most optimum of values and elements
return(list(value=ret_value, elements=elements))
}
}
library(KnapsackPack)
library(devtools)
usethis::use_package("parallel")
devtools::load_all(".")
devtools::load_all(".")
library(KnapsackPack)
library(KnapsackPack)
